/* FILE: make_particlce.c
 * AUTH: Alfons Hoekstra
 * DESCR: This module initializes the dipole set, either using predefined shapes 
 *        or reading from a file. Includes granule generator.
 *
 *        rewriten,
 *        Michel Grimminck 1995
 *        -----------------------------------------------------------
 *        included ellipsoidal particle for work with Victor Babenko
 *        september 2002
 *        --------------------------------------------------------
 *        included many more new particles:
 *        leucocyte, stick, rotatable oblate spheroid, lymphocyte,
 *        rotatable RBC, etc etc etc
 *        December 2003 - February 2004, by Konstantin Semyanov
 *          (not used now)
 *
 *        Currently is developed by Maxim Yurkin
 *
 * Copyright (C) 2006-2007 University of Amsterdam
 * This code is covered by the GNU General Public License.
 */
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <time.h>     /* for time and clock (used for random seed) */
#include <limits.h>
#include "vars.h"
#include "const.h"
#include "cmplx.h"
#include "types.h"
#include "comm.h"
#include "debug.h"
#include "memory.h"
#include "io.h"
#include "param.h"
#include "timing.h"
#include "mt19937ar.h"

/* SEMI-GLOBAL VARIABLES */

/* defined and initialized in param.c */
extern const int shape,sh_Npars;
extern const double sh_pars[];
extern const int symmetry_enforced;
extern const double lambda;
extern double sizeX,dpl;
extern const int jagged;
extern const char aggregate_file[];
extern char shapename[];
extern char save_geom_fname[];
extern const int volcor,save_geom;
extern opt_index opt_sh;
extern const double gr_vf;
extern double gr_d;
extern const int gr_mat;

/* defined and initialized in timing.c */
extern TIME_TYPE Timing_Particle,Timing_Granul,Timing_Granul_comm;

/* used in param.c */
int volcor_used;                 /* volume correction was actually employed */
char sh_form_str[MAX_PARAGRAPH]; /* string for log file with shape parameters */
size_t gr_N;                     /* number of granules */
double gr_vf_real;               /* actual granules volume fraction */
double mat_count[MAX_NMAT+1];    /* number of dipoles in each domain */

/* LOCAL VARIABLES */

static const char geom_format[] = "%d %d %d\n";         /* format of the geom file */
static const char geom_format_ext[] = "%d %d %d %d\n";  /* extended format of the geom file */
static double volume_ratio; /* ratio of scatterer volume to enclosing cube;
                               used for dpl correction */
static double Ndip;         /* total number of dipoles (in a circumscribing cube) */
static double dpl_def;      /* default value of dpl */
/* shape parameters */
static double coat_ratio,coat_x,coat_y,coat_z,coat_r2;
static double diskratio,ellipsY,ellipsZ;
static double P,Q,R,S;         /* for RBC */
/* TO ADD NEW SHAPE
   add all internal variables (aspect ratios, etc.) here.
   Add descriptive comments, use 'static'. */

/* temporary arrays before their real counterparts are allocated */
static unsigned char *material_tmp;
static double *DipoleCoord_tmp;
static unsigned short *position_tmp;

/*============================================================*/

static void SaveGeometry(void)
  /* saves dipole configuration to .geom file */
{
  char fname[MAX_FNAME];
  FILE *geom;
  size_t i,j;

  /* create save_geom_fname if not specified */
  if (save_geom_fname[0]==0)
    sprintf(save_geom_fname,"%s.geom",shapename);
  /* choose filename */
#ifdef PARALLEL
  sprintf(fname,"%s/" F_GEOM_TMP,directory,ringid);
#else
  sprintf(fname,"%s/%s",directory,save_geom_fname);
#endif
  geom=FOpenErr(fname,"w",ALL_POS);
  /* print head of file */
#ifdef PARALLEL
  if (ringid==0) {  /* this condition can be different from being ROOT */
#endif
    fprintf(geom,"#generated by ADDA v." ADDA_VERSION "\n"\
                 "#shape: '%s'\n"\
                 "#box size: %dx%dx%d\n",
                 shapename,boxX,boxY,boxZ);
    if (Nmat>1) fprintf(geom,"Nmat=%d\n",Nmat);
#ifdef PARALLEL
  }     /* end of if */
#endif
  /* save geometry */
  if (Nmat>1) for(i=0;i<local_nvoid_Ndip;i++) {
    j=3*i;
    fprintf(geom,geom_format_ext,position[j],position[j+1],position[j+2],material[i]+1);
  }
  else for(i=0;i<local_nvoid_Ndip;i++) {
    j=3*i;
    fprintf(geom,geom_format,position[j],position[j+1],position[j+2]);
  }
  FCloseErr(geom,fname,ALL_POS);
#ifdef PARALLEL
  /* wait for all processes to save their part of geometry */
  Synchronize();
  /* combine all files into one and clean */
  if (ringid==ROOT) CatNFiles(directory,F_GEOM_TMP,save_geom_fname);
#endif
  PRINTZ("Geometry saved to file\n");
}

/*===========================================================*/

static int SkipComments(FILE *file)
  /* skips comments (#...), all lines, starting from current position in a file
     returns number of lines skipped */
{
  int lines=0,ch;
  char buf[BUF_LINE];

  while ((ch=fgetc(file))=='#') {
    do fgets(buf,BUF_LINE,file); while (strstr(buf,"\n")==NULL && !feof(file));
    lines++;
  }
  if (ch!=EOF) ungetc(ch,file);

  return lines;
}

/*===========================================================*/

static void InitDipFile(const char *fname, int *maxX, int *maxY, int *maxZ, int *Nm)
   /* read dipole file first to determine box sizes and Nmat;
      input is not checked for very large numbers (integer overflows) to increase speed */
{
  FILE *input;
  int x, y, z, ext=FALSE, cond, mat, line=0;
  char buf[BUF_LINE];

  input=FOpenErr(fname,"r",ALL_POS);

  line=SkipComments(input)+1;
  /* read Nmat if present */
  if (fscanf(input,"Nmat=%d\n",Nm)!=1) *Nm=1;
  else {
    ext=TRUE;
    if (*Nm<=0) LogError(EC_ERROR,ONE_POS,"Nmat is nonpositive, as given in %s",fname);
    if (*Nm==1) LogError(EC_INFO,ONE_POS,
                         "Nmat is given in dipole file - %s, but is trivial (=1)",fname);
    line++;
  }
  /* scan main part of the file */
  *maxX=*maxY=*maxZ=0;
     /* reading is performed in lines */
  while(fgets(buf,BUF_LINE,input)!=NULL) {
    if (strstr(buf,"\n")==NULL && !feof(input)) LogError(EC_ERROR,ONE_POS,
      "Buffer overflow while scanning lines in file '%s' (size of line %d > %d)",
      fname,line,BUF_LINE-1);
    if (ext) cond=(sscanf(buf,geom_format_ext,&x,&y,&z,&mat)!=4);
    else cond=(sscanf(buf,geom_format,&x,&y,&z)!=3);
    if (cond)
      LogError(EC_ERROR,ONE_POS,"Could not scan from dipole file - %s - line %d",fname,line);
    /* check for errors in values */
    if (x<0)
      LogError(EC_ERROR,ONE_POS,"Negative coordinate - %s - line %d: x=%d",fname,line,x);
    if (y<0)
      LogError(EC_ERROR,ONE_POS,"Negative coordinate - %s - line %d: y=%d",fname,line,y);
    if (z<0)
      LogError(EC_ERROR,ONE_POS,"Negative coordinate - %s - line %d: z=%d",fname,line,z);
    if (ext) {
      if (mat<=0) LogError(EC_ERROR,ONE_POS,
                           "Nonpositive material number - %s - line %d: mat=%d",fname,line,mat);
      if (mat>*Nm) LogError(EC_ERROR,ONE_POS,
        "Given material number - %s - line %d: mat=%d is greater than provided Nmat (%d)",
        fname,line,mat,*Nm);
    }    
    /* update maximums */
    if (x>*maxX) *maxX=x;
    if (y>*maxY) *maxY=y;
    if (z>*maxZ) *maxZ=z;
    line++;
  }
  *maxX=jagged*(*maxX+1);
  *maxY=jagged*(*maxY+1);
  *maxZ=jagged*(*maxZ+1);
  FCloseErr(input,fname,ALL_POS);
}

/*===========================================================*/

static void ReadDipFile(const char *fname)
   /* read dipole file;
       no consistency checks are made since they are made in InitDipFile */
{
  FILE *input;
  int x, y, z, x0, y0, z0, mat, ext=FALSE;
  int index;
  char buf[BUF_LINE];
  size_t boxXY,boxX_l;

  /* to remove possible overflows */
  boxX_l=(size_t)boxX;
  boxXY=boxX_l*boxY;

  input=FOpenErr(fname,"r",ALL_POS);

  SkipComments(input);
  /* skip Nmat if present */
  if (fscanf(input,"Nmat=%d\n",&mat)==1) ext=TRUE;
  else mat=1;

  while(fgets(buf,BUF_LINE,input)!=NULL) {
    if (ext) sscanf(buf,geom_format_ext,&x0,&y0,&z0,&mat);
    else sscanf(buf,geom_format,&x0,&y0,&z0);

    for (z=jagged*z0;z<jagged*(z0+1);z++) if (z>=local_z0 && z<local_z1_coer)
      for (x=jagged*x0;x<jagged*(x0+1);x++) for (y=jagged*y0;y<jagged*(y0+1);y++) {
        index=(z-local_z0)*boxXY+y*boxX_l+x;
        material_tmp[index]=(unsigned char)(mat-1);
    }
  }
  FCloseErr(input,fname,ALL_POS);
}

/*==========================================================*/

#define KEY_LENGTH 2         /* length of key for initialization of random generator */
#define MAX_ZERO_FITS 1E4    /* maximum number of zero fits in a row (each - many granules) */
#define MAX_FALSE_SKIP 10    /* number of false skips in granule placement to complete the set */
#define MAX_FALSE_SKIP_SMALL 10  /* the same for small granules */
#define MAX_GR_SET USHRT_MAX /* maximum size of granule set */
#define MIN_CELL_SIZE 4.0    /* minimum cell size for small granules */

INLINE int CheckCell(const double *gr,const double *vgran,const unsigned short *tree_index,
                     const double Di2,const int start,int *fits)
   /* function that checks whether granule intersects anything in the cell */
{
  int index,last,index1;
  double t1,t2,t3;

  last=index=start;
  while (index!=MAX_GR_SET && (*fits)) {
    last=index;
    index1=3*index;
    t1=gr[0]-vgran[index1];
    t2=gr[1]-vgran[index1+1];
    t3=gr[2]-vgran[index1+2];
    if ((t1*t1+t2*t2+t3*t3)<Di2) *fits=FALSE;
    index=tree_index[index];
  }
  return last;
}
/*==========================================================*/

static double PlaceGranules(void)
 /* rangomly places granules inside the specified domain;
    Mersenne Twister is used for generating random numbers

    A simplest algorithm is used: to place randomly a sphere, and see if it overlaps with any
    dipoles (more exactly: centers of dipoles) of not correct domain; if not, accept it and
    fill all this dipoles with granules' domain. Optimized to perform in two steps:
    Firtst it places of set of not-intersecting granules and do only a quick ckeck against the
    "domain pattern" - coarse representation of the domain. On the second step granules of the
    whole set are thorougly checked against the whole domain on each processor. When small
    granules are used, no domain pattern is used - makes it simpler.
    Intersection of two granules between the sets is checked only through dipoles, which is not
    exact, however it allows considering arbitrary complex domains, which is described only by
    a set of occupied dipoles.
    This algorithm is unsuitable for high volume fractions, it becomes very slow and for some
    volume fractions may fail at all (Metropolis algorithm should be more suitable, however it
    is hard to code for arbitrary domains). Moreover, statistical properties of the obtained
    granules distribution may be not perfect, however it seems good enough for our applications.

    Currently it is not working with jagged. That should be improved, by rewriting the jagged
    calculation throughout the program */

{
  int i,j,k,zerofit,last;
  size_t n,count,count_gr,false_count,ui;
  size_t boxXY;
  double nd;                           /* number of dipoles occupied by granules */
  int index,index1,index2;             /* indices for dipole grid */
  int dom_index,dom_index1,dom_index2; /* indices for auxilliary grid */
  int gX,gY,gZ;                        /* auxilliary grid dimensions */
  size_t gXY,gr_gN;                    /* ... and their products */
  size_t avail;                        /* number of available (free) domain cells */
  int gX2,gY2,gZ2,locgZ2;
  int i0,i1,j0,j1,k0,k1;
  int fits;
  int cur_Ngr,ig,max_Ngr; /* number of granules in a current set, index, and maximum set size */
  double gdX,gdY,gdZ,gdXh,gdYh,gdZh;  /* auxilliary grid cell sizes and their halfs (h) */
  int locz0,locz1,locgZ,gr_locgN;
  double R,R2,Di,Di2;             /* radius and dimater of granule, and their squares */
  double x0,x1,y0,y1,z0,z1;     /* where to put random number (inner box) */
  int id0,id1,jd0,jd1,kd0,kd1;  /* dipoles limit that fall inside inner box */
  int Nfit;          /* number of succesfully placed granules in a current set */
  double overhead;   /* estimate of the overhead needed to have exactly needed N of granules */
  double tmp1,tmp2,tmp3,t1,t2,t3;
  int sx,sy,sz;          /* maximum shifts for checks of neighboring cells in auxilliary grid
                            for 'small' it is the shift in index */
  unsigned long key[KEY_LENGTH];  /* key to initialize random number generator */
  unsigned char *dom;    /* information about the domain on a granule grid */
  unsigned short *occup; /* information about the occupied cells */
  int sm_gr;             /* whether granules are small (then simpler algorithm is used) */
  unsigned short *tree_index; /* index for traversing granules inside one cell (for small) */
  double *vgran;         /* coordinates of a set of granules */
  char *vfit;            /* results of granule fitting on the grid (boolean) */
  int *ginX,*ginY,*ginZ; /* indices to find dipoles inside auxilliary grid */
  int indX,indY,indZ;    /* indices for doubled auxilliary grid */
  int bit;               /* bit position in char of 'dom' */
  double gr[3];          /* coordinates of a single granule */

  /* set variables; consider jagged */
  Di=gr_d/(gridspace*jagged);
  if (Di<1) LogError(EC_WARN,ONE_POS,"Granule diameter is smaller than dipole size. "\
                                     "It is recommended to increase resolution");
  R=Di/2;
  R2=R*R;
  Di2=4*R2;
  boxXY=boxX*(size_t)boxY;
    /* inner box */
  if (Di>MIN(boxX,MIN(boxY,boxZ))) LogError(EC_WARN,ONE_POS,
               "Granule size is larger than minimum particle dimension");
  x0=R-0.5;
  x1=boxX-R-0.5;
  y0=R-0.5;
  y1=boxY-R-0.5;
  z0=R-0.5;
  z1=boxZ-R-0.5;
    /* initialize auxilliary grid */
  CheckOverflow(MAX(boxX,MAX(boxY,boxZ))*10/Di,ONE_POS,"PlaceGranules()");
  tmp1=sqrt(3)/Di;
  gX=(int)ceil((x1-x0)*tmp1);
  gdX=(x1-x0)/gX;
  gY=(int)ceil((y1-y0)*tmp1);
  gdY=(y1-y0)/gY;
  gZ=(int)ceil((z1-z0)*tmp1);
  gdZ=(z1-z0)/gZ;
  sm_gr=(gdX<2 || gdY<2 || gdZ<2); /* sets the discrimination for small or large granules */
  if (sm_gr) {
    PRINTZ("Using algorithm for small granules\n");
    /* redefine auxilliary grid */
    tmp1=1/MAX(2*Di,MIN_CELL_SIZE);
    gX=(int)floor((x1-x0)*tmp1);
    gdX=(x1-x0)/gX;
    gY=(int)floor((y1-y0)*tmp1);
    gdY=(y1-y0)/gY;
    gZ=(int)floor((z1-z0)*tmp1);
    gdZ=(z1-z0)/gZ;
  }
  else {
    PRINTZ("Using algorithm for large granules\n");
    gX2=2*gX;
    gdXh=gdX/2;
    gY2=2*gY;
    gdYh=gdY/2;
    gZ2=2*gZ;
    gdZh=gdZ/2;
    /* this sets maximum distance of neighboring cells to check; condition gdX<R can only occur
       if gX<=7, which is quite rare, so no optimization is performed. sx>3 can only occur if
       gX<=2 and then it doesn't make sense to take bigger sx. Absolutely analogous for y, z. */
    if (gdX<R) sx=3;
    else sx=2;
    if (gdY<R) sy=3;
    else sy=2;
    if (gdZ<R) sz=3;
    else sz=2;
  }
  gXY=MultOverflow(gX,gY,ONE_POS,"PlaceGranules()");
  gr_gN=MultOverflow(gXY,gZ,ONE_POS,"PlaceGranules()");
     /* calculate maximum number of granules in a grid; crude estimate */
  tmp2=(ceil((x1-x0)/Di)+1)*(ceil((y1-y0)/Di)+1)*(ceil((z1-z0)/Di)+1);
  max_Ngr=MIN(MAX_GR_SET,tmp2);
     /* local z grid + initialize communications */
  SetGranulComm(z0,z1,gdZ,gZ,gXY,max_Ngr,&locz0,&locz1,sm_gr);
  if (!sm_gr) {
    locgZ=locz1-locz0;
    locgZ2=2*locgZ;
    gr_locgN=gXY*locgZ;
  }
  if (ringid==ROOT) {
    /* init random generator */
    key[0]=(unsigned long)time(NULL);
    key[1]=(unsigned long)(clock()-wt_start);
    init_by_array(key,KEY_LENGTH);
    /* allocate memory */
    MALLOC_VECTOR(occup,ushort,gr_gN,ONE);
    if (sm_gr) MALLOC_VECTOR(tree_index,ushort,max_Ngr,ONE);
    else MALLOC_VECTOR(dom,uchar,gr_gN,ALL);
  }
  else if (!sm_gr && locgZ!=0) MALLOC_VECTOR(dom,uchar,gr_locgN,ALL);
  MALLOC_VECTOR(vgran,double,3*max_Ngr,ALL);
  MALLOC_VECTOR(vfit,char,max_Ngr,ALL);
  if (!sm_gr && locgZ!=0) {
    /* build some more indices */
    MALLOC_VECTOR(ginX,int,gX2+1,ALL);
    MALLOC_VECTOR(ginY,int,gY2+1,ALL);
    MALLOC_VECTOR(ginZ,int,locgZ2+1,ALL);
    for (i=0;i<=gX2;i++) ginX[i]=(int)ceil(x0+i*gdXh);
    id0=ginX[0];
    id1=ginX[gX2];
    for (i=0;i<=gY2;i++) ginY[i]=(int)ceil(y0+i*gdYh);
    jd0=ginY[0];
    jd1=ginY[gZ2];
    for (i=0;i<=locgZ2;i++) ginZ[i]=(int)ceil(z0+(i+2*locz0)*gdZh);
    kd0=MAX(ginZ[0],local_z0);
    indZ=1;
    if (kd0>=ginZ[1]) indZ++;
    kd1=MIN(ginZ[locgZ2],local_z1_coer);
  }
  n=count=count_gr=false_count=0;
  nd=0;
    /* crude estimate of the probability to place a small granule into domain */
  if (sm_gr) overhead=Ndip/mat_count[gr_mat];
  else overhead=1;
  /* main cycle */
  while (n<gr_N) {
    if (sm_gr) {  /* small granules */
       /* just generate granules */
      if (ringid==ROOT) {
        cur_Ngr=MIN(ceil((gr_N-n)*overhead),max_Ngr);
        /* generate points and quick check */
        ig=false_count=0;
        for (ui=0;ui<gr_gN;ui++) occup[ui]=MAX_GR_SET;  /* used as undef */
        while (ig<cur_Ngr) {
          count++;
          false_count++;
          fits=TRUE;
          /* random position in a grid */
          gr[0]=genrand(0,gX);
          gr[1]=genrand(0,gY);
          gr[2]=genrand(0,gZ);
          /* coordinates in a grid */
          t1=floor(gr[0]);
          t2=floor(gr[1]);
          t3=floor(gr[2]);
          indX=(int)t1;
          indY=(int)t2;
          indZ=(int)t3;
          t1=gr[0]-t1;       /* t_i are distances to the edges */
          t2=gr[1]-t2;
          t3=gr[2]-t3;
          /* convert to usual coords (in dipole grid) */
          gr[0]=gr[0]*gdX+x0;
          gr[1]=gr[1]*gdY+y0;
          gr[2]=gr[2]*gdZ+z0;
          index=indZ*gXY+indY*gX+indX;
          last=CheckCell(gr,vgran,tree_index,Di2,occup[index],&fits);
             /* weird construction (7 inclosed ifs) but should be fast */
          if (fits) {
            /* possible x-neighbour */
            t1*=gdX;   /* transform shifts to usual coords; done only when needed */
            sx=0;
            if (t1<Di) {
              if (indX!=0) sx=-1;
            }
            else if ((t1=gdX-t1)<Di && indX!=gX-1) sx=1;
            if (sx!=0) CheckCell(gr,vgran,tree_index,Di2,occup[index+sx],&fits);
            if (fits) {
              /* possible y-neighbour */
              t2*=gdY;
              sy=0;
              if (t2<Di) {
                if (indY!=0) sy=-gX;
              }
              else if ((t2=gdY-t2)<Di && indY!=gY-1) sy=gX;
              if (sy!=0) CheckCell(gr,vgran,tree_index,Di2,occup[index+sy],&fits);
              if (fits) {
                /* possible z-neighbour */
                t3*=gdZ;
                sz=0;
                if (t3<Di) {
                  if (indZ!=0) sz=-(int)gXY;
                }
                else if ((t3=gdZ-t3)<Di && indZ!=gZ-1) sz=gXY;
                if (sz!=0) CheckCell(gr,vgran,tree_index,Di2,occup[index+sz],&fits);
                if (fits) {
                  /* possible xy-neighbour */
                  if (sx!=0 && sy!=0 && ((tmp1=t1*t1)+(tmp2=t2*t2)<Di2))
                    CheckCell(gr,vgran,tree_index,Di2,occup[index+sx+sy],&fits);
                  if (fits) {
                    /* possible xz-neighbour */
                    if (sx!=0 && sz!=0 && ((tmp1+(tmp3=t3*t3))<Di2))
                      CheckCell(gr,vgran,tree_index,Di2,occup[index+sx+sz],&fits);
                    if (fits) {
                      /* possible yz-neighbour & xyz-neighbour */
                      if (sy!=0 && sz!=0 && (tmp2+tmp3<Di2)) {
                        CheckCell(gr,vgran,tree_index,Di2,occup[index+sy+sz],&fits);
                        if (fits && sx!=0 && (tmp1+tmp2+tmp3<Di2))
                          CheckCell(gr,vgran,tree_index,Di2,occup[index+sx+sy+sz],&fits);
                      }
                    }
                  }
                }
              }
            }
          }
          if (fits) {
            memcpy(vgran+3*ig,gr,3*sizeof(double));
            tree_index[ig]=MAX_GR_SET;
            if (last==MAX_GR_SET) occup[index]=(unsigned short)ig;
            else tree_index[last]=(unsigned short)ig;
            ig++;
            false_count=0;
          }
          if (false_count>MAX_FALSE_SKIP_SMALL) break;
        }
        /* real number of placed granules for this set */
        cur_Ngr=ig;
      }
    }
    else {   /* large granules */
      /* generate domain pattern */
      if (locgZ!=0) {
        for (i=0;i<gr_locgN;i++) dom[i]=0;
        dom_index2=0;
        index2=(kd0-local_z0)*boxXY;
        bit=((indZ&1)^1)<<2;
        for (k=kd0;k<kd1;k++,index2+=boxXY) {
          index1=index2+jd0*boxX;
          dom_index1=dom_index2;
          indY=1;
          bit&=~2;
          for (j=jd0;j<jd1;j++,index1+=boxX) {
            index=index1+id0;
            dom_index=dom_index1;
            indX=1;
            bit&=~1;
            for (i=id0;i<id1;i++,index++) {
              if (material_tmp[index]!=gr_mat) dom[dom_index]|=(unsigned char)(1<<bit);
              if (i+1==ginX[indX]) {
                indX++;
                bit^=1;
                if (indX&1) dom_index++;
              }
            }
            if (j+1==ginY[indY]) {
              indY++;
              bit^=2;
              if (indY&1) dom_index1+=gX;
            }
          }
          if (k+1==ginZ[indZ]) {
            indZ++;
            bit^=4;
            if (indZ&1) dom_index2+=gXY;
          }
        }
      }
      /* send/collect domain pattern */
      CollectDomainGranul(dom,gXY,locz0,locgZ,&Timing_Granul_comm);
      if (ringid==ROOT) {
        /* analyze domain pattern */
        avail=0;
        for (ui=0;ui<gr_gN;ui++) if (dom[ui]!=0xFF) avail++;
        cur_Ngr=MIN(avail,(size_t)max_Ngr);
        tmp1=(gr_N-n)*overhead;
        if (cur_Ngr>tmp1) cur_Ngr=(int)ceil(tmp1);
        /* generate points and quick check */
        ig=false_count=0;
        for (ui=0;ui<gr_gN;ui++) occup[ui]=MAX_GR_SET;  /* used as undef */
        while (ig<cur_Ngr) {
          count++;
          /* random position in a double grid */
          gr[0]=genrand(0,gX2);
          gr[1]=genrand(0,gY2);
          gr[2]=genrand(0,gZ2);
          /* coordinates in doubled grid */
          indX=(int)floor(gr[0]);
          indY=(int)floor(gr[1]);
          indZ=(int)floor(gr[2]);       /* position bit inside one cell */
          bit=1<<((indX&1)+((indY&1)<<1)+((indZ&1)<<2));
          /* coordinates in usual grid */
          indX/=2;
          indY/=2;
          indZ/=2;
          index=indZ*gXY+indY*gX+indX;
          /* two simple checks */
          if (!(dom[index]&bit) && occup[index]==MAX_GR_SET) {
            /* convert to usual coords (in dipole grid) */
            gr[0]=gr[0]*gdXh+x0;
            gr[1]=gr[1]*gdYh+y0;
            gr[2]=gr[2]*gdZh+z0;
            fits=TRUE;
            false_count++;
            if ((i0=indX-sx)<0) i0=0;
            if ((i1=indX+sx+1)>gZ) i1=gX;
            if ((j0=indY-sy)<0) j0=0;
            if ((j1=indY+sy+1)>gY) j1=gY;
            if ((k0=indZ-sz)<0) k0=0;
            if ((k1=indZ+sz+1)>gZ) k1=gZ;
            dom_index2=k0*gXY;
            for (k=k0;k<k1;k++,dom_index2+=gXY) {
              dom_index1=dom_index2+j0*gX;
              for (j=j0;j<j1;j++,dom_index1+=gX) {
                dom_index=dom_index1+i0;
                for (i=i0;i<i1;i++,dom_index++) if (occup[dom_index]!=MAX_GR_SET) {
                  index1=3*occup[dom_index];
                  t1=gr[0]-vgran[index1];
                  t2=gr[1]-vgran[index1+1];
                  t3=gr[2]-vgran[index1+2];
                  if ((t1*t1+t2*t2+t3*t3)<Di2) {
                    fits=FALSE;
                    break;
                  }
                }
                if (!fits) break;
              }
              if (!fits) break;
            }
            if (fits) {
              memcpy(vgran+3*ig,gr,3*sizeof(double));
              occup[index]=(unsigned short)ig;
              ig++;
              false_count=0;
              /* Here it is possible to correct the domain pattern because of the presence
                 of a new granule. However it probably will be useful only for large volume
                 fractions */
            }
            if (false_count>MAX_FALSE_SKIP) break;
          }
        }
        /* real number of placed granules for this set */
        cur_Ngr=ig;
      }
    }  /* end of large granules */
    /* cast to all processors */
    MyBcast(&cur_Ngr,int_type,1,&Timing_Granul_comm);
    MyBcast(vgran,double_type,3*cur_Ngr,&Timing_Granul_comm);
    count_gr+=cur_Ngr;
    /* final check if granules belong to the domain */
    for (ig=0;ig<cur_Ngr;ig++) {
      memcpy(gr,vgran+3*ig,3*sizeof(double));
      k0=MAX((int)ceil(gr[2]-R),local_z0);
      k1=MIN((int)floor(gr[2]+R),local_z1_coer-1);
      fits=TRUE;
      index2=(k0-local_z0)*boxXY;
      for (k=k0;k<=k1;k++,index2+=boxXY) {
        tmp1=R2-(gr[2]-k)*(gr[2]-k);
        tmp2=sqrt(tmp1);
        j0=(int)ceil(gr[1]-tmp2);
        j1=(int)floor(gr[1]+tmp2);
        index1=index2+j0*boxX;
        for (j=j0;j<=j1;j++,index1+=boxX) {
          tmp2=sqrt(tmp1-(gr[1]-j)*(gr[1]-j));
          i0=(int)ceil(gr[0]-tmp2);
          i1=(int)floor(gr[0]+tmp2);
          index=index1+i0;
          for (i=i0;i<=i1;i++,index++) {
            if (material_tmp[index]!=gr_mat) {
              fits=FALSE;
              break;
            }
          }
          if (!fits) break;
        }
        if (!fits) break;
      }
      vfit[ig]=(char)fits;
    }
    /* collect fits */
    ExchangeFits(vfit,cur_Ngr,&Timing_Granul_comm);
    /* fit dipole grid with successive granules */
    Nfit=n;
    for (ig=0;ig<cur_Ngr;ig++) {
      if (vfit[ig]) {
        /* a succesful granule */
        n++;
        /* fill dipoles in the sphere with granule material */
        memcpy(gr,vgran+3*ig,3*sizeof(double));
        k0=MAX((int)ceil(gr[2]-R),local_z0);
        k1=MIN((int)floor(gr[2]+R),local_z1_coer-1);
        index2=(k0-local_z0)*boxXY;
        for (k=k0;k<=k1;k++,index2+=boxXY) {
          tmp1=R2-(gr[2]-k)*(gr[2]-k);
          tmp2=sqrt(tmp1);
          j0=(int)ceil(gr[1]-tmp2);
          j1=(int)floor(gr[1]+tmp2);
          index1=index2+j0*boxX;
          for (j=j0;j<=j1;j++,index1+=boxX) {
            tmp2=sqrt(tmp1-(gr[1]-j)*(gr[1]-j));
            i0=(int)ceil(gr[0]-tmp2);
            i1=(int)floor(gr[0]+tmp2);
            index=index1+i0;
            for (i=i0;i<=i1;i++,index++) {
              material_tmp[index]=(unsigned char)(Nmat-1);
              nd++;
            }
          }
        }
        /* if the allocation was too oprimistic */
        if (n>=gr_N) break;
      }
    }
    Nfit=n-Nfit;
    /* overhead is estimated based on the estimation of mean value - 1*standard deviation
       for the probability of fiting one granule. It is estimated from the Bernulli statistics
       k out of n successful hits. M(p)=(k+1)/(n+2); s^2(p)=(k+1)(n-k+1)/(n+3)(n+2)^2
       M(p)-s(p)=[(k+1)/(n+2)]*[1-sqrt((n-k+1)/(k+1)(n+3))];
       overhead=1/latter */
    overhead=(cur_Ngr+2)/((1-sqrt((cur_Ngr-Nfit+1)/(double)((Nfit+1)*(cur_Ngr+3))))*(Nfit+1));
    if (Nfit!=0) zerofit=0;
    else {
      zerofit++;
      /* check if taking too long */
      if (zerofit>MAX_ZERO_FITS) {
        MyInnerProduct(&nd,double_type,1,&Timing_Granul_comm);
        LogError(EC_ERROR,ONE_POS,
          "The granule generator failed to reach required volume fraction (%g) of granules. "\
          "%u granules were successfully placed up to a volume fraction of %g",
          gr_vf,n,nd/mat_count[gr_mat]);
      }
    }
  }
  PRINTZ("Granule generator: total random placements= %u (efficiency 1 = %g)\n"\
         "                   possible granules= %u (efficiency 2 = %g)\n",
         count,count_gr/(double)count,count_gr,gr_N/(double)count_gr);
  MyInnerProduct(&nd,double_type,1,&Timing_Granul_comm);
  /* free everything */
  if (ringid==ROOT) {
    Free_general(occup);
    if (sm_gr) Free_general(tree_index);
    else Free_general(dom);
  }
  else if (!sm_gr && locgZ!=0) Free_general(dom);
  FreeGranulComm(sm_gr);
  Free_general(vgran);
  Free_general(vfit);
  if (!sm_gr && locgZ!=0) {
    Free_general(ginX);
    Free_general(ginY);
    Free_general(ginZ);
  }
  return nd;
}
#undef KEY_LENGTH
#undef MAX_ZERO_FITS
#undef MAX_FALSE_SKIP
#undef MAX_FALSE_SKIP_SMALL
#undef MAX_GR_SET
#undef MIN_CELL_SIZE
/*==========================================================*/

static int FitBox(const int box)
   /* finds the smallest value for which program would work
      (should be even and divide jagged); the limit is also checked */
{
  int res;

  if (jagged%2==0) res=jagged*((box+jagged-1)/jagged);
  else res=2*jagged*((box+2*jagged-1)/(2*jagged));
  if (res>BOX_MAX) LogError(EC_ERROR,ONE_POS,
                            "Derived grid size (%d) is too large (>%d)",res,BOX_MAX);
  return res;
}

/*==========================================================*/

void InitShape(void)
   /* perform of initialization of symmetries and boxY, boxZ
    * Estimate the volume of the particle, when not discretisized.
    * Check whether enough refractive indices are specified
    */
{
  int n_boxX, n_boxYi, n_boxZi, temp;   /* new values for dimensions */
  double h_d,b_d,c_d,h2,b2,c2;
  double n_boxY,n_boxZ,tmp;
  TIME_TYPE tstart;
  int Nmat_need,i;
  int dpl_def_used;   /* if default dpl is used for grid initialization */

  tstart=GET_TIME();
  /* for some shapes volume_ratio is initialized below;
     if not, volume correction is not used */
  volume_ratio=UNDEF;
  /* calculate default dpl - 10*sqrt(max(|m|));
     for anisotropic each component is considered separately */
  dpl_def=0;
  for (i=0;i<Ncomp*Nmat;i++) {
    tmp=cAbs2(ref_index[i]);
    if (dpl_def<tmp) dpl_def=tmp;
  }
  dpl_def=10*sqrt(dpl_def);
  dpl_def_used=FALSE;
  /* if box is not defined by command line or read from file;
        if size is defined, dpl is initialized to default, and grid is calculated
                (dpl is slightly corrected aferwards)
        else grid is initialized to default
     then (in make_particle() ) the dpl is determined from size (if it is defined)
         or set by default (after it size is determined */
  if (boxX==UNDEF) {
    if (shape!=SH_READ) {
      if (sizeX!=UNDEF) {
        if (dpl==UNDEF) {
          dpl=dpl_def;  /* default value of dpl */
          dpl_def_used=TRUE;
        }
        boxX=FitBox((int)ceil(sizeX*dpl/lambda));
        dpl=UNDEF;     /* dpl is given correct value in make_particle() */
      }
      else boxX=DEF_GRID; /* default value for boxX */
    }
  }
  else {
    temp=boxX;
    if ((boxX=FitBox(boxX))!=temp)
      LogError(EC_WARN,ONE_POS,"boxX has been adjusted from %i to %i",temp,boxX);
  }
  n_boxX=boxX;

  /* initialization of global option index for error messages */
  opt=opt_sh;
  /* shape initialization */
  if (shape==SH_BOX) {
    STRCPYZ(sh_form_str,"cube; size of edge:%.10g");
    if (boxY!=UNDEF && boxY!=boxX) symR=FALSE;
    n_boxY=n_boxZ=boxX;
    Nmat_need=1;
  }
  else if (shape==SH_COATED) {
    coat_ratio=sh_pars[0];
    TestRange(coat_ratio,"innner/outer diameter ratio",0,1);
    SPRINTZ(sh_form_str,"coated sphere; diameter(d):%%.10g, inner diameter d_in/d=%.10g",
            coat_ratio);
    if (sh_Npars==4) {
      coat_x=sh_pars[1];
      coat_y=sh_pars[2];
      coat_z=sh_pars[3];
      if (coat_x*coat_x+coat_y*coat_y+coat_z*coat_z>0.25*(1-coat_ratio)*(1-coat_ratio))
        PrintErrorHelp("Inner sphere is not fully inside the outer");
      SPRINTZ(sh_form_str+strlen(sh_form_str),
              "\n       position of inner sphere center r/d= {%.10g,%.10g,%.10g}",
              coat_x,coat_y,coat_z);
    }
    else coat_x=coat_y=coat_z=0; /* initialize default values */
    coat_r2=0.25*coat_ratio*coat_ratio;
    volume_ratio=PI_OVER_SIX;
    if (coat_x!=0) symX=symR=FALSE;
    if (coat_y!=0) symY=symR=FALSE;
    if (coat_z!=0) symZ=FALSE;
    n_boxY=n_boxZ=boxX;
    Nmat_need=2;
  }
  else if(shape==SH_CYLINDER) {
    diskratio=sh_pars[0];
    TestPositive(diskratio,"height to diameter ratio");
    SPRINTZ(sh_form_str,"cylinder; diameter(d):%%.10g, height h/d=%.10g",diskratio);
    volume_ratio=PI_OVER_FOUR*diskratio;
    n_boxY=boxX;
    n_boxZ=diskratio*boxX;
    Nmat_need=1;
  }
  else if (shape==SH_ELLIPSOID) {
    ellipsY=sh_pars[0];
    TestPositive(ellipsY,"aspect ratio y/x");
    ellipsZ=sh_pars[1];
    TestPositive(ellipsZ,"aspect ratio z/x");
    SPRINTZ(sh_form_str,"ellipsoid; size along X:%%.10g, aspect ratios y/x=%.10g, z/x=%.10g",
            ellipsY,ellipsZ);
    if (ellipsY!=1) symR=FALSE;
    volume_ratio=PI_OVER_SIX*ellipsY*ellipsZ;
    n_boxY=ellipsY*boxX;
    n_boxZ=ellipsZ*boxX;
    Nmat_need=1;
  }
  else if (shape==SH_LINE) {
    STRCPYZ(sh_form_str,"line; legth:%g");
    symY=symZ=symR=FALSE;
    n_boxY=n_boxZ=jagged;
    Nmat_need=1;
  }
  else if(shape==SH_RBC) {
    /* three-parameter shape; developed by K.A.Semyanov,P.A.Tarasov,P.A.Avrorov
       based on work by P.W.Kuchel and E.D.Fackerell, "Parametric-equation representation
       of biconcave erythrocytes," Bulletin of Mathematical Biology 61, 209-220 (1999). */
    h_d=sh_pars[0];
    TestPositive(h_d,"ratio of maximum width to diameter");
    b_d=sh_pars[1];
    TestPositive(b_d,"ratio of minimum width to diameter");
    if (h_d <= b_d) PrintErrorHelp("given RBC is not biconcave; maximum width is in the center");
    c_d=sh_pars[2];
    TestRange(c_d,"relative diameter of maximum width",0,1);
    SPRINTZ(sh_form_str,
      "red blood cell; diameter(d):%%.10g, maximum and minimum width h/d=%.10g, b/d=%.10g\n"\
      "       diameter of maximum width c/d=%.10g",h_d,b_d,c_d);
    /* calculate shape parameters */
    h2=h_d*h_d;
    b2=b_d*b_d;
    c2=c_d*c_d;
    P=(b2*((c2*c2/(h2-b2))-h2)-1)/4;
    R=-(P+0.25)/4;
    Q=((P+0.25)/b2)-(b2/4);
    S=-(2*P+c2)/h2;

    n_boxY=boxX;
    n_boxZ=h_d*boxX;
    volume_ratio=UNDEF;
    Nmat_need=1;
  }
  else if (shape==SH_READ) {
    SPRINTZ(sh_form_str,"specified by file %s; size along X:%%.10g",aggregate_file);
    symX=symY=symZ=symR=FALSE; /* input file is assumed assymetric */
    InitDipFile(aggregate_file,&n_boxX,&n_boxYi,&n_boxZi,&Nmat_need);
    n_boxY=n_boxYi;
    n_boxZ=n_boxZi;
  }
  else if (shape==SH_SPHERE) {
    STRCPYZ(sh_form_str,"sphere; diameter:%.10g");
    volume_ratio=PI_OVER_SIX;
    n_boxY=n_boxZ=boxX;
    Nmat_need=1;
  }
  else if (shape==SH_SPHEREBOX) {
    coat_ratio=sh_pars[0];
    TestRange(coat_ratio,"sphere diameter/cube edge ratio",0,1);
    SPRINTZ(sh_form_str,
      "sphere in cube; size of cube edge(a):%%.10g, diameter of sphere d/a=%.10g",coat_ratio);
    coat_r2=0.25*coat_ratio*coat_ratio;
    if (boxY!=UNDEF || boxY!=boxX) symR=FALSE;
    n_boxY=n_boxZ=boxX;
    Nmat_need=2;
  }
  /* TO ADD NEW SHAPE
     add an option here (in the end of 'else if' sequence). Identifier ('SH_...') should be
     defined in const.h. The option should
     1) save all the input parameters from array 'sh_pars' to local variables
        (defined in the beginning of this source files)
     2) test all input parameters (for that you're encouraged to use functions from param.h since
        they would automatically produce informative output in case of error). If the shape can
        accept different number of parameters (UNDEF was set in array shape_opt) then also test the
        number of parameters.
     3) if shape breaks any symmetry, corresponding variable should be set to FALSE. Do not set
        any of them to TRUE, as they can be set to FALSE by some other factors.
        symX, symY, symZ - symmetries of reflection over planes YZ, XZ, XY respectively.
        symR - symmetry of rotation for 90 degrees over the Z axis
     4) initialize the following:
     sh_form_str - descriptive string, should contain %g - it would be replaced by box size along
                   x-axis afterwards (in param.c).
     n_boxY, n_boxZ - grid sizes along y and z-axes (here they are double) calculated from
                      size along x-axis. It is done from particle aspect ratios in _particle_
                      reference frame. They are transformed to integer grid sizes afterwards.
     Nmat_need - number of different domains in this shape (void is not included)
     volume_ratio - (optional) ratio of particle volume to (boxX)^3.
                     Initialize it if it can be calculated analytically.
     all other auxiliary variables that are used in shape generation (below), variables should
            be defined in the beginning of this file. */

/*  else if(shape==SH_SDISK_ROT) {
    symX=symY=symZ=FALSE;
    symR=FALSE;
    volume_ratio=boxX*boxX*boxX;
  }
  else if (shape==SH_PRISMA) {
    symX=TRUE;
    symY=symZ=FALSE;
    symR=FALSE;
    volume_ratio=.5*boxX*boxY*boxZ;
  }  */

  /* initialize domain granulation */
  if (sh_granul) {
    symX=symY=symZ=symR=FALSE;  /* no symmetry with granules */
    if (gr_mat+1>Nmat_need) LogError(EC_ERROR,ONE_POS,
      "Specified domain number to be granulated (%d) is larger than total number of domains (%d) "\
      "for the given shape (%s)",gr_mat+1,Nmat_need,shapename);
    else Nmat_need++;
    strcat(shapename,"_gran");
  }
  /* check if enough refr. indices or extra */
  if (Nmat<Nmat_need) {
    if (prognose) {
      if (dpl_def_used) LogError(EC_INFO,ONE_POS,"Given number of refractive indices (%d) is less"\
        " than number of domains (%d). Since computational grid is initialized based on the"\
        " default dpl, it may change depending on the actual refractive indices.",Nmat,Nmat_need);
    }
    else LogError(EC_ERROR,ONE_POS,
                  "Only %d refractive indices are given. %d are required",Nmat,Nmat_need);
  }
  else if (Nmat>Nmat_need) LogError(EC_INFO,ONE_POS,
    "More refractive indices are given (%d) than actually used (%d)",Nmat,Nmat_need);
  Nmat=Nmat_need;

  /* ckeck anisotropic refractive indices for symmetries */
  if (anisotropy) for (i=0;i<Nmat;i++) symR=symR && ref_index[3*i][RE]==ref_index[3*i+1][RE]
                                                 && ref_index[3*i][IM]==ref_index[3*i+1][IM];

  if (symmetry_enforced) symX=symY=symZ=symR=TRUE;
  else if (NoSymmetry) symX=symY=symZ=symR=FALSE;

  if (boxX==UNDEF) boxX=FitBox(n_boxX);
  else if (n_boxX>boxX) LogError(EC_ERROR,ONE_POS,
                        "Particle (boxX=%d) does not fit into specified boxX=%d", n_boxX, boxX);

  n_boxYi=(int)ceil(n_boxY);
  n_boxZi=(int)ceil(n_boxZ);
  if (boxY==UNDEF) { /* assumed that boxY and boxZ are either both defined or both not defined */
    boxY=FitBox(n_boxYi);
    boxZ=FitBox(n_boxZi);
  }
  else {
    temp=boxY;
    if ((boxY=FitBox(boxY))!=temp)
      LogError(EC_WARN,ONE_POS,"boxY has been adjusted from %i to %i",temp,boxY);
    temp=boxZ;
    if ((boxZ=FitBox(boxZ))!=temp)
      LogError(EC_WARN,ONE_POS,"boxZ has been adjusted from %i to %i",temp,boxZ);
    /* this error is not duplicated in the logfile since it does not yet exist */
    if (n_boxYi>boxY || n_boxZi>boxZ) LogError(EC_ERROR,ONE_POS,
      "Particle (boxY,Z={%d,%d}) does not fit into specified boxY,Z={%d,%d}",
      n_boxYi,n_boxZi,boxY,boxZ);
  }
  /* initialize number of dipoles */
  Ndip=boxX*((double)boxY)*boxZ;
  /* initialize maxiter; not very realistic */
  if (maxiter==UNDEF) maxiter=MIN(INT_MAX,3*Ndip);
  /* initialize nTheta */
  if (nTheta==UNDEF) {
    if (Ndip<1000) nTheta=91;
    else if (Ndip<10000) nTheta=181;
    else if (Ndip<100000) nTheta=361;
    else nTheta=721;
  }
  /* this limitation should be removed in the future */
  if (chp_type!=CHP_NONE && (!symR || scat_grid)) LogError(EC_ERROR,ONE_POS,
      "Currently checkpoints can be used when internal fields are calculated only once,"\
      "i.e. for a single incident polarization.");
  Timing_Particle = GET_TIME() - tstart;
}

/*==========================================================*/

void MakeParticle(void)
  /* creates a particle; initializes all dipoles counts, dpl, gridspace */
{
  int i, j, k;
  size_t index,dip,nlocalRows_tmp;
  double a_eq,tmp1,tmp2,tmp3;
  double xr,yr,zr,xcoat,ycoat,zcoat,r2,z2;
  double cX,cY,cZ,jcX,jcY,jcZ;  /* centers for DipoleCoord and jagged */
  int xj,yj,zj;
  int mat;
  unsigned short us_tmp;
  TIME_TYPE tstart,tgran;

  tstart=GET_TIME();

  index=0;
  /* assumed that box's are even */
  jcX=jcY=jcZ=jagged/2.0;
  cX=(boxX-1)/2.0;
  cY=(boxY-1)/2.0;
  cZ=(boxZ-1)/2.0;
  nlocalRows_tmp=MultOverflow(3,local_Ndip,ALL_POS,"nlocalRows_tmp");
  /* allocate temporary memory; even if prognose, since they are needed for exact estimation
     they will be reallocated afterwards (when nlocalRows is known) */
  MALLOC_VECTOR(material_tmp,uchar,local_Ndip,ALL);
  MALLOC_VECTOR(DipoleCoord_tmp,double,nlocalRows_tmp,ALL);
  MALLOC_VECTOR(position_tmp,ushort,nlocalRows_tmp,ALL);

  for(k=local_z0;k<local_z1_coer;k++)
    for(j=0;j<boxY;j++)
      for(i=0;i<boxX;i++) {
        xj=jagged*(i/jagged)-boxX/2;
        yj=jagged*(j/jagged)-boxY/2;
        zj=jagged*(k/jagged)-boxZ/2;

        xr=(xj+jcX)/(boxX);
        yr=(yj+jcY)/(boxX);
        zr=(zj+jcZ)/(boxX);

        mat=Nmat;  /* corresponds to void */

        if (shape==SH_BOX) mat=0;
        else if (shape==SH_COATED) {
          xcoat=xr-coat_x;
          ycoat=yr-coat_y;
          zcoat=zr-coat_z;
          if (xcoat*xcoat+ycoat*ycoat+zcoat*zcoat <= coat_r2) mat=1;
          else if (xr*xr+yr*yr+zr*zr <= 0.25) mat=0;
        }
        else if (shape==SH_CYLINDER) {
          if((fabs(zr) <= diskratio/2) && (xr*xr + yr*yr <= 0.25)) mat = 0;
        }
        else if (shape==SH_ELLIPSOID) {
          if (xr*xr + yr*yr/(ellipsY*ellipsY) + zr*zr/(ellipsZ*ellipsZ) <= 0.25) mat = 0;
        }
        else if (shape==SH_LINE) {
          if (yr>=0 && yr<=jagged/2.0 && zr>=0 && zr<=jagged/2.0) mat=0;
        }
        else if (shape==SH_SPHERE) {
          if (xr*xr+yr*yr+zr*zr <= 0.25) mat=0;
        }
        else if (shape==SH_SPHEREBOX) {
          if (xr*xr+yr*yr+zr*zr <= coat_r2) mat=1;
          else mat=0;
        }
        else if (shape==SH_RBC) {
          r2=xr*xr+yr*yr;
          z2=zr*zr;
          if (r2*r2+2*S*r2*z2+z2*z2+P*r2+Q*z2+R <= 0) mat=0;
        }
        /* TO ADD NEW SHAPE
           add an option here (in the end of 'else if' sequence). Identifier ('SH_...') should be
           defined in const.h. This option should set 'mat' - index of domain for a point,
           specified by {xr,yz,zr} - coordinates divided by grid size along X (xr from -0.5 to 0.5,
           others - depending on aspect ratios). C array indexing used: mat=0 - first domain, etc.
           If point corresponds to void, do not set 'mat'. */

/*        else if  (shape==SH_SDISK_ROT) {
          xr= (i+centreX)/(boxX);
          yr= (j+centreY)/(boxY);
          zr= (k+centreZ)/(boxZ);
          CY=cos(PI/180*betaY);  SY=sin(PI/180*betaY);
          CZ=cos(PI/180*betaZ);  SZ=sin(PI/180*betaZ);
          xr_=xr*CY*CZ-yr*SZ-zr*SY*CZ;
          yr_=xr*CY*SZ+yr*CZ-zr*SY*SZ;
          zr_=xr*SY+zr*CY;
          cthick=(aspect_r)/2.0;
          radius=(xr_*xr_+yr_*yr_+zr_*zr_)/0.25;
          if (radius <1.0000001 && xr_<cthick && xr_>-cthick) mat=0;
        }
        else if (shape==SH_PRISMA && y*boxZ>=-z*boxY) mat=0;*/

        position_tmp[3*index]=(unsigned short)i;
        position_tmp[3*index+1]=(unsigned short)j;
        position_tmp[3*index+2]=(unsigned short)k;
        /* afterwards multiplied by gridspace */
        DipoleCoord_tmp[3*index]=i-cX;
        DipoleCoord_tmp[3*index+1]=j-cY;
        DipoleCoord_tmp[3*index+2]=k-cZ;
        material_tmp[index]=(unsigned char)mat;
        index++;
  } /* End box loop */
  if (shape==SH_READ) ReadDipFile(aggregate_file);
  /* initialization of mat_count and dipoles counts */
  for(i=0;i<=Nmat;i++) mat_count[i]=0;
  for(dip=0;dip<local_Ndip;dip++) mat_count[material_tmp[dip]]++;
  local_nvoid_Ndip=local_Ndip-mat_count[Nmat];
  MyInnerProduct(mat_count,double_type,Nmat+1,NULL);
  if ((nvoid_Ndip=Ndip-mat_count[Nmat])==0)
    LogError(EC_ERROR,ONE_POS,"All dipoles of the scatterer are void");
  nlocalRows=3*local_nvoid_Ndip;
  /* initialize dpl and gridspace */
  volcor_used=(volcor && (volume_ratio!=UNDEF));
  if (sizeX==UNDEF) {
    if (dpl==UNDEF) dpl=dpl_def; /* default value of dpl */
    /* sizeX is determined to give correct volume */
    if (volcor_used) sizeX=lambda*pow(nvoid_Ndip/volume_ratio,ONE_THIRD)/dpl;
    else sizeX=lambda*boxX/dpl;
  }
  else {
    if (dpl!=UNDEF)
      LogError(EC_ERROR,ONE_POS,"Extra information (all of dpl,grid,size) are given");
    /* dpl is determined to give correct volume */
    if (volcor_used) dpl=lambda*pow(nvoid_Ndip/volume_ratio,ONE_THIRD)/sizeX;
    else dpl=lambda*boxX/sizeX;
  }
  gridspace=lambda/dpl;
  /* initialize equivalent size parameter and cross section */
  kd = TWO_PI/dpl;
  a_eq = pow(THREE_OVER_FOUR_PI*nvoid_Ndip,ONE_THIRD)*gridspace;
  ka_eq = WaveNum*a_eq;
  inv_G = 1/(PI*a_eq*a_eq);
  /* granulate one domain, if needed */
  if (sh_granul) {
    tgran=GET_TIME();
    Timing_Granul_comm=0;
    /* calculate number of granules */
    if (mat_count[gr_mat]==0) LogError(EC_ERROR,ONE_POS,
                                       "Domain to be granulated does not contain any dipoles");
    tmp1=gridspace/gr_d;
    tmp2=mat_count[gr_mat]*gr_vf*SIX_OVER_PI;
    tmp3=tmp2*tmp1*tmp1*tmp1;
    CheckOverflow(tmp3,ONE_POS,"Make_Particle()");
    gr_N=(size_t)ceil(tmp3);
    /* correct granules diameter to get exact volume fraction (if volume correction is used) */
    if (volcor_used) gr_d=gridspace*pow(tmp2/gr_N,ONE_THIRD);
    /* actually place granules */
    mat_count[Nmat-1]=PlaceGranules();
    /* calculate exact volume fraction */
    gr_vf_real=mat_count[Nmat-1]/mat_count[gr_mat];
    mat_count[gr_mat]-=mat_count[Nmat-1];
    Timing_Granul=GET_TIME()-tgran;
  }
  /* allocate main particle arrays, using precise nlocalRows
     even when '-prognose' is used to enable save_geom afterwards */
  MALLOC_VECTOR(material,uchar,local_nvoid_Ndip,ALL);
  MALLOC_VECTOR(DipoleCoord,double,nlocalRows,ALL);
  MALLOC_VECTOR(position,ushort,nlocalRows,ALL);

  memory+=(3*(sizeof(short int)+sizeof(double))+sizeof(char))*local_nvoid_Ndip;
  /* copy nontrivial part of arrays */
  index=0;
  for (dip=0;dip<local_Ndip;dip++) if (material_tmp[dip]<Nmat) {
    material[index]=material_tmp[dip];
     /* DipoleCoord=gridspace*DipoleCoord_tmp */
    MultScal(gridspace,DipoleCoord_tmp+3*dip,DipoleCoord+3*index);
    memcpy(position+3*index,position_tmp+3*dip,3*sizeof(short int));
    index++;
  }
  /* free temporary memory */
  Free_general(material_tmp);
  Free_general(DipoleCoord_tmp);
  Free_general(position_tmp);

  /* save geometry */
  if (save_geom) SaveGeometry();

  /* adjust z-axis of position vector, to speed-up matvec a little bit
     after this point 'position(z)' is taken relative to the local_z0 */
  if (local_z0!=0) {
    us_tmp=(unsigned short)local_z0;
    for (dip=2;dip<3*local_nvoid_Ndip;dip+=3) position[dip]-=us_tmp;
  }

  Timing_Particle += GET_TIME() - tstart;
}

